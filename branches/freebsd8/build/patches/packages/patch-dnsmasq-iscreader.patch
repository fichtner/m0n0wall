diff -urN dnsmasq-2.60.orig/Makefile dnsmasq-2.60/Makefile
--- Makefile	2012-04-25 17:52:14.000000000 +0200
+++ Makefile	2012-10-17 16:30:41.000000000 +0200
@@ -65,7 +65,7 @@
 objs = cache.o rfc1035.o util.o option.o forward.o network.o \
        dnsmasq.o dhcp.o lease.o rfc2131.o netlink.o dbus.o bpf.o \
        helper.o tftp.o log.o conntrack.o dhcp6.o rfc3315.o \
-       dhcp-common.o outpacket.o radv.o slaac.o
+       dhcp-common.o outpacket.o radv.o slaac.o isc.o
 
 hdrs = dnsmasq.h config.h dhcp-protocol.h dhcp6-protocol.h \
        dns-protocol.h radv-protocol.h
diff -urN dnsmasq-2.60.orig/src/config.h dnsmasq-2.60/src/config.h
--- src/config.h	2012-03-04 21:04:22.000000000 +0100
+++ src/config.h	2012-04-25 17:52:43.000000000 +0200
@@ -60,6 +60,10 @@
    NOTE: when enabling or disabling this, be sure to delete any old
    leases file, otherwise dnsmasq may get very confused.
 
+HAVE_ISC_READER 
+   define this to include the old ISC dhcpcd integration. Note that you cannot
+   set both HAVE_ISC_READER and HAVE_BROKEN_RTC.
+
 HAVE_TFTP
    define this to get dnsmasq's built-in TFTP server.
 
@@ -121,10 +125,15 @@
 #define HAVE_SCRIPT
 /* #define HAVE_LUASCRIPT */
 /* #define HAVE_BROKEN_RTC */
+#define HAVE_ISC_READER
 /* #define HAVE_DBUS */
 /* #define HAVE_IDN */
 /* #define HAVE_CONNTRACK */
 
+#if defined(HAVE_BROKEN_RTC) && defined(HAVE_ISC_READER)
+#  error HAVE_ISC_READER is not compatible with HAVE_BROKEN_RTC
+#endif
+
 
 
 /* Default locations for important system files. */
@@ -322,6 +331,10 @@
 #ifdef NO_FORK
 "no-MMU "
 #endif
+#ifndef HAVE_ISC_READER
+"no-"
+#endif
+"ISC "
 #ifndef HAVE_DBUS
 "no-"
 #endif
diff -urN dnsmasq-2.60.orig/src/dnsmasq.c dnsmasq-2.60/src/dnsmasq.c
--- src/dnsmasq.c	2012-03-04 21:04:22.000000000 +0100
+++ src/dnsmasq.c	2012-04-25 17:52:44.000000000 +0200
@@ -90,6 +90,10 @@
       if (daemon->dhcp || daemon->dhcp6)
 	daemon->lease_file = LEASEFILE;
     }
+#ifndef HAVE_ISC_READER
+  else if (!daemon->dhcp)
+    die(_("ISC dhcpd integration not available: set HAVE_ISC_READER in src/config.h"), NULL, EC_BADCONF);
+#endif
 #endif
   
   /* Close any file descriptors we inherited apart from std{in|out|err} 
@@ -751,6 +755,11 @@
 	  difftime(now, daemon->last_resolv) > 1.0 || 
 	  difftime(now, daemon->last_resolv) < -1.0)
 	{
+#ifdef HAVE_ISC_READER
+	  if (daemon->lease_file && !daemon->dhcp)
+	    load_dhcp(now);
+#endif
+
 	  /* poll_resolv doesn't need to reload first time through, since 
 	     that's queued anyway. */
 
diff -urN dnsmasq-2.60.orig/src/dnsmasq.h dnsmasq-2.60/src/dnsmasq.h
--- src/dnsmasq.h	2012-03-04 21:04:22.000000000 +0100
+++ src/dnsmasq.h	2012-04-25 17:52:44.000000000 +0200
@@ -972,6 +972,11 @@
 void clear_cache_and_reload(time_t now);
 void poll_resolv(int force, int do_reload, time_t now);
 
+/* isc.c */
+#ifdef HAVE_ISC_READER
+void load_dhcp(time_t now);
+#endif
+
 /* netlink.c */
 #ifdef HAVE_LINUX_NETWORK
 void netlink_init(void);
diff -urN dnsmasq-2.60.orig/src/isc.c dnsmasq-2.60/src/isc.c
--- src/isc.c	1970-01-01 01:00:00.000000000 +0100
+++ src/isc.c	2012-04-25 17:52:44.000000000 +0200
@@ -0,0 +1,249 @@
+/* dnsmasq is Copyright (c) 2000-2007 Simon Kelley
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 dated June, 1991, or
+   (at your option) version 3 dated 29 June, 2007.
+ 
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+     
+  You should have received a copy of the GNU General Public License
+  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+
+/* Code in this file is based on contributions by John Volpe. */
+
+#include "dnsmasq.h"
+
+#ifdef HAVE_ISC_READER
+
+#define MAXTOK 50
+
+struct isc_lease {
+  char *name, *fqdn;
+  time_t expires;
+  struct in_addr addr;
+  struct isc_lease *next;
+};
+
+static struct isc_lease *leases = NULL;
+static off_t lease_file_size = (off_t)0;
+static ino_t lease_file_inode = (ino_t)0;
+static int logged_lease = 0;
+
+static int next_token (char *token, int buffsize, FILE * fp)
+{
+  int c, count = 0;
+  char *cp = token;
+  
+  while((c = getc(fp)) != EOF)
+    {
+      if (c == '#')
+	do { c = getc(fp); } while (c != '\n' && c != EOF);
+      
+      if (c == ' ' || c == '\t' || c == '\n' || c == ';')
+	{
+	  if (count)
+	    break;
+	}
+      else if ((c != '"') && (count<buffsize-1))
+	{
+	  *cp++ = c;
+	  count++;
+	}
+    }
+  
+  *cp = 0;
+  return count ? 1 : 0;
+}
+
+void load_dhcp(time_t now)
+{
+  char *hostname = daemon->namebuff;
+  char token[MAXTOK], *dot;
+  struct in_addr host_address;
+  time_t ttd, tts;
+  FILE *fp;
+  struct isc_lease *lease, *tmp, **up;
+  struct stat statbuf;
+
+  if (stat(daemon->lease_file, &statbuf) == -1)
+    {
+      if (!logged_lease)
+	my_syslog(LOG_WARNING, _("failed to access %s: %s"), daemon->lease_file, strerror(errno));
+      logged_lease = 1;
+      return;
+    }
+  
+  logged_lease = 0;
+  
+  if ((statbuf.st_size <= lease_file_size) &&
+      (statbuf.st_ino == lease_file_inode))
+    return;
+  
+  lease_file_size = statbuf.st_size;
+  lease_file_inode = statbuf.st_ino;
+  
+  if (!(fp = fopen (daemon->lease_file, "r")))
+    {
+      my_syslog (LOG_ERR, _("failed to load %s: %s"), daemon->lease_file, strerror(errno));
+      return;
+    }
+
+  while ((next_token(token, MAXTOK, fp)))
+    {
+      if (strcmp(token, "lease") == 0)
+        {
+          hostname[0] = '\0';
+	  ttd = tts = (time_t)(-1);
+	  if (next_token(token, MAXTOK, fp) && 
+	      (host_address.s_addr = inet_addr(token)) != (in_addr_t) -1)
+            {
+              if (next_token(token, MAXTOK, fp) && *token == '{')
+                {
+                  while (next_token(token, MAXTOK, fp) && *token != '}')
+                    {
+                      if ((strcmp(token, "client-hostname") == 0) ||
+			  (strcmp(token, "hostname") == 0))
+			{
+			  if (next_token(hostname, MAXDNAME, fp))
+			    if (!canonicalise(hostname, 0))
+			      {
+				*hostname = 0;
+				my_syslog(LOG_ERR, _("bad name in %s"), daemon->lease_file); 
+			      }
+			}
+                      else if ((strcmp(token, "ends") == 0) ||
+			       (strcmp(token, "starts") == 0))
+                        {
+                          struct tm lease_time;
+			  int is_ends = (strcmp(token, "ends") == 0);
+			  if (next_token(token, MAXTOK, fp) &&  /* skip weekday */
+			      next_token(token, MAXTOK, fp) &&  /* Get date from lease file */
+			      sscanf (token, "%d/%d/%d", 
+				      &lease_time.tm_year,
+				      &lease_time.tm_mon,
+				      &lease_time.tm_mday) == 3 &&
+			      next_token(token, MAXTOK, fp) &&
+			      sscanf (token, "%d:%d:%d:", 
+				      &lease_time.tm_hour,
+				      &lease_time.tm_min, 
+				      &lease_time.tm_sec) == 3)
+			    {
+			      /* There doesn't seem to be a universally available library function
+				 which converts broken-down _GMT_ time to seconds-in-epoch.
+				 The following was borrowed from ISC dhcpd sources, where
+                                 it is noted that it might not be entirely accurate for odd seconds.
+				 Since we're trying to get the same answer as dhcpd, that's just
+				 fine here. */
+			      static const int months [11] = { 31, 59, 90, 120, 151, 181,
+							       212, 243, 273, 304, 334 };
+			      time_t time = ((((((365 * (lease_time.tm_year - 1970) + /* Days in years since '70 */
+						  (lease_time.tm_year - 1969) / 4 +   /* Leap days since '70 */
+						  (lease_time.tm_mon > 1                /* Days in months this year */
+						   ? months [lease_time.tm_mon - 2]
+						   : 0) +
+						  (lease_time.tm_mon > 2 &&         /* Leap day this year */
+						   !((lease_time.tm_year - 1972) & 3)) +
+						  lease_time.tm_mday - 1) * 24) +   /* Day of month */
+						lease_time.tm_hour) * 60) +
+					      lease_time.tm_min) * 60) + lease_time.tm_sec;
+			      if (is_ends)
+				ttd = time;
+			      else
+				tts = time;			    }
+                        }
+		    }
+		  
+		  /* missing info? */
+		  if (!*hostname)
+		    continue;
+		  if (ttd == (time_t)(-1))
+		    continue;
+		  
+		  /* We use 0 as infinite in ttd */
+		  if ((tts != -1) && (ttd == tts - 1))
+		    ttd = (time_t)0;
+		  else if (difftime(now, ttd) > 0)
+		    continue;
+
+		  if ((dot = strchr(hostname, '.')))
+		    { 
+		      if (!daemon->domain_suffix || hostname_isequal(dot+1, daemon->domain_suffix))
+			{
+			  my_syslog(LOG_WARNING, 
+				    _("Ignoring DHCP lease for %s because it has an illegal domain part"), 
+				    hostname);
+			  continue;
+			}
+		      *dot = 0;
+		    }
+
+		  for (lease = leases; lease; lease = lease->next)
+		    if (hostname_isequal(lease->name, hostname))
+		      {
+			lease->expires = ttd;
+			lease->addr = host_address;
+			break;
+		      }
+
+		  if (!lease && (lease = whine_malloc(sizeof(struct isc_lease))))
+		    {
+		      lease->expires = ttd;
+		      lease->addr = host_address;
+		      lease->fqdn =  NULL;
+		      lease->next = leases;
+		      if (!(lease->name = whine_malloc(strlen(hostname)+1)))
+			free(lease);
+		      else
+			{
+			  leases = lease;
+			  strcpy(lease->name, hostname);
+			  if (daemon->domain_suffix && 
+			      (lease->fqdn = whine_malloc(strlen(hostname) + strlen(daemon->domain_suffix) + 2)))
+			    {
+			      strcpy(lease->fqdn, hostname);
+			      strcat(lease->fqdn, ".");
+			      strcat(lease->fqdn, daemon->domain_suffix);
+			    }
+			}
+		    }
+		}
+	    }
+	}
+    }
+
+  fclose(fp);
+  
+  /* prune expired leases */
+  for (lease = leases, up = &leases; lease; lease = tmp)
+     {
+       tmp = lease->next;
+       if (lease->expires != (time_t)0 && difftime(now, lease->expires) > 0)
+	 {
+	   *up = lease->next; /* unlink */
+	   free(lease->name);
+	   if (lease->fqdn)
+	     free(lease->fqdn);
+	   free(lease);
+	 }
+       else
+	 up = &lease->next;
+     }
+
+     
+  /* remove all existing DHCP cache entries */
+  cache_unhash_dhcp();
+
+  for (lease = leases; lease; lease = lease->next)
+    {
+      cache_add_dhcp_entry(lease->fqdn, AF_INET, (struct all_addr *)&lease->addr, lease->expires);
+      cache_add_dhcp_entry(lease->name, AF_INET, (struct all_addr *)&lease->addr, lease->expires);
+    }
+}
+
+#endif
